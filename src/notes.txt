/*
C++ 

MODELS
OOO -> based on "Models". You can define an object in many ways, choose what you need to: you don't need a car's number of seats if you're creating racecars
but you need it for a car retailer.

ENCAPSULATION

Of Models; to only include information about themselves.
Don't include gas price in the car model; the gas station model would have it.

CLASS & STRUCT
- Class Members are by default PRIVATE 
- Struct Members are by default PUBLIC
Classes contain two types of members: data + function
Car.make, Car.paint
Each instance = an object of the class (can have 3 car objects)
    CONSTRUCTORS
    Function to define the class within a class definition:
        className( arg1, arg2){
            var1 = arg1;
            var2 = arg2;
        }
    Best practice: discernable names (_i for initializer variables)
    As a function, can be Overloaded for different parameters!
    Automatically allocates memory for members in the stack.
    Must do it manually for the Heap.
        heapMember = new type

    this KEYWORD
        Acts as pointer to the current instance(object)
            this->memberName = value;
        Lets you reuse names by being explicit about the scope:
            Inventory(int capacity){
                this->capacity = capacity //Member var capacity is set to the constructor's parameter 'capacity' 
            }
        So common in constructors there's a shorthand:
        MEMBER INITIALIZATION LIST
        className(args): memberName(value), memberName2(value2) {} //Requires different names for member and argument (_i for initializer is common)
            
    DESTRUCTORS
    Function to define how an object is destroyed.
    Declaration: ~className();
    Implementation: className::~className(){}

    Occurs when destroyed (out of scope on the stack, or explicitly on the Heap w/ delete)
    If your class created extra objects on the Heap, they have to be deleted manually too. Destructor is a good place to ensure it. 
        ~Inventory(){
            delete items; //Heap-allocated member.
        }
    ACCESS
    Of Members.
    Private : accessible only by itself, not even by inherited classes
    Public : accessible by any other part of the code
    Protected : accessible by itself and inherited classes

        GETTERS and SETTERS
        To keep variables from being read and written by other objects directly, add validation, etc., access is restricted.
        "ADDERS"/"MODIFIERS"
        The act of modifying the contents of a member (ex: adding an element to the target of a vector pointer member).
        Not modifying the Pointer, only the contents of what's pointed to.



    INHERITANCE AND POLYMORPHISM
    Subclasses (class based on another) and superclasses (the class it inherits from)
    Poly = Function can be implemented differently in subclasses (inherited) vs superclass
    "Children" and "Sibling" classes with these re-implementations are polymorphic.

    Can add on to a parent's implementation by calling it in the Child's polymorphic implementation.
        See "using" Declarations (not directives)
        By default, children classes don't have their parents' functions in their scope. Can still be called: the parent's scope is used.
        With the "using" declaration, can define a polymorphic implementation at the scope of the child class, using the same identifier.

        INHERITANCE ACCESS SPECIFIERS
        Private: When you want to implement a derived class from a base class, but you don't want the derived class to expose the base class's interface.
            EX: I want to implement a virtual function (which had to be Protected), but I don't want any further children to redefine it.
        Protected: When you want to provide access to the base class's members to the derived class and its further derived classes, but not to users of the derived class.
            EX: I want to implement a derived class, but restrict its public members to protected (use-case???)

        COMPOSITION
            Creating a member variable of a base class' type in a derived class.

        SYNTAX
        class B : specifier A {...} 


        OVERRIDING FUNCTIONS
        Typically used with Virtual (if you want to guarantee the Child's override is used even if called using parentType).
            SYNTAX
            returnType funcName(args) override{//body}
    ABSTRACT CLASS (see Functions in notes_members)
    Enforced parent classes (cannot have instances)
    Used as interfaces to implement
    Contains methods without implementation (pure virtual), strictly Signatures.

    VIRTUAL BASE CLASS
    For inheritance structure management: Prevented from being present multiple times when multiple-inheritance is applied.
        I assume: C inherits B (which inherits A) and A. Error unless Virtual.

SYNTAX
Case-Sensitive
Indents ignored by converters, but readability ++
; at end of most lines, specifically at the end of STATEMENTS.
    STATEMENTS do not return values, they only do actions. (Representation of an action)
    EXPRESSIONS return values from constants, variables and operators. (Representation of a calculation)
        ASSIGNMENTS expressions is code that assigns a value to a variable. It assigns a value to a variable and then returns the value assigned. Left-hand side must be able to contain value, right-hand side is an expression that will define the value. Data Type must match (keeping implicit conversion in mind: just because it works doesn't mean it's working as intended)
Library inclusions are NOT statements. (Preprocessor Directive)
Functions are NOT statements. It only links a sequence of statements (body of the function) to a name/arguments/etc.

TOKENS
Smallest unit of any CPP program; they cannot be evaluated & simplified down.
    
Examples: 
Keywords: #include, int, if, return
    Reserved words
    Qualifiers : const, volatile...  Modifications to how the compiler handles variables and constructs
Identifiers: iostream, main, x, std, cout, endl
    Variable names, functions, classes... Start w/ letter or underscore. Only contains letters, digits, underscores.
Literals: 10, 5, "x is greater than 5"
    Constant values. 2+2 is NOT a literal, it is an expression, but 4 is.
Operators: +, =, >, <<
    Assignment?, Arithmetic, comparisons, logical operators
Punctuators: <, >, ;, {, }, (, )
    Code structure



RESERVED IDENTIFIERS (KEYWORDS)
int float double char bool if else switch case default for while do return void class struct public private protected virtual new delete const static namespace using try catch throw nullptr
    AVOID
    same words with difference Case (Class vs class)
    Underscores at beginning of identifiers : compilers often use those.
        Private member variables are often used this way (less risk of conflict??)


NAMESPACES
Splits in your code (regions) to separate otherwise identical names. If using a  library, you can use some of its functions by telling C++ to use a specific region. The scope resolution operator serves that purpose ::

//Similar to Houdini's "Geometry" inputs - you have to tell the program where to find the model's members

HEADER FILES
IOStream is one! Contains different objects and functions.
<string> header includes the class and functions to manipulate the Class/data

LIBRARIES
https://cplusplus.com/reference/iolibrary/
Collections of objects and member functions to avoid rewriting them.
Inclusions: #include <library> (IOStream is one of the headers from the standard library) 
Libraries contain header file(s) sharing a purpose.
Example hierarchy:

Standard Library  cppreference.com
    Input/Output library. Namespace == std.
    All below are therefore accessed using std::

        

        <iomanip> (iomanip.h) header, for manipulators of inputs/outputs, not only streams.
            ::get_time (function) gets characters from the input stream, interpreting as time and date
        
        <iostream> (iostream.h) header, specifically handling the "Streams". Abstractions called streams are specially designed to perform input and output operations on sequences of character, like files or strings. Can be used to print to screen and receive text from keyboard
            ::cin (object) standard input stream. Often used with >> extraction operator. (Single word only)
                Use function ____ instead for multiple words. 
            ::cout (object) character ouput, standard output stream object (typically the Terminal)
            ::flush Produces a line immediately with the contents of the out-stream object. Often used before a cin.
            ::endl Newline character in the ouput. Produces a line immediately.
        <fstream> file stream (text files)
        Similar to cin object from iostream: the input is the text.
            ::ifstream - class of the INPUT file stream (can create vars of type ifstream)
                fileVar.open(string path, relative from same directory)
                fileVar.close()
                    Closes document, emptying var as well
                fileVar.eof()
                    Iterator returning a line at a time until it reaches end of File. Can use while(!file.eof())
                    Linked with getline to know if at eof.

                fileVar.fail()
                    Bool TRUE if file isnt' found, or already open by another program.

                getline(fileVar, str)
                    Returns next std:string line in the str variable.
                FILE MODES: to define how file is handled.
                ios::app (Append), ::in(Input, reading), ::out (output, writing)    
            ::ofstream - Class of the OUTPUT file stream
            ::ostream - Parent Class of output streams : cout, ofstream, etc. Can use it as argument(reference) to make a function that can output to any output stream.  std::cout can be passed as a parameter, or a file with ofstream...
        <cstdio> C (language) standard Input output
            printf("Hello World!\n")

        <vector> Vector container class
        <string> String Class (array of characters w/ supporting functions)
            std::to_string(var)
        <cstring> C-Style Strings functions, to manipulate Char arrays.
            Always has a "null" character at the end, to tell Computer it's the end of the string. Must make sure, as some string functions could keep going past our string if not careful.
                Assign last element: 
                    arrayName[(sizeof(array)-1)]= ('\0');
            strncpy(buffer,string,max string size) //string copy 
                Arrays let you use sizeof()
            strlen()
                Returns number of characters in the string (not its max size) 
            strncat(A, B, maxCharactersToAddToResultArray) or strcat_s()
                max = sizeof(A) - strlen(A) - 1
        <algorithm> Sorting, searching, manipulating data
            ::find(iteratorStart,iteratorEnd, itemToFind), returns iterator to found element or element past last element(end() iterator)
            std::transform(), replaces "map": 
                Applies function/UnaryOperator/binaryOp to a range defined by 2 iterators. Outputs results at a 3rd iterator.
                    unary_op = unary function object that outputs an iterator : must be dereferenceable & implicitly convertible to Type

                    Used with back_inserter(value) instead of end() to work with empty containers: gets an iterator to the end of that empty container.
            ::copy_if() , replaces "filter"
                Similar to transform. Requires a collection to output. Instead of applying function to value, only adds it if the (unary_op)function returns TRUE. It inserts the element of the collection into the single argument of the function.
        <memory> Smart Pointers. ex: shared_ptr, unique_ptr

        <locale> Localization features
        <thread> Class + funcs to create and handle threads
        <mutex> Mutual exclusion primitives for thread synchronization 

        <chrono> Functions to keep track of time
            ::system_clock //Object connected to the system's clock. 
                Object::now() //Current time
            ::time_point<clockObject> //A point in time. start, end, midway...
            ::duration<double> //Allows arithmetic to work with TimePoints (overloaded operator in TimePoint class)

        
        <utility>

        <memory> Pointer-related functions, like smart pointers

        <complex> Complex numbers
            complex<varType>(real,imaginary)
                Template, with constructor using REAL + IMAGINARY parts
                Template definition operators < > can be problematic on older compilers when stacked:
                    std::vector<std::complex<double>> varName //Here, a vector variable, of type complex number (double float). >> CAN be mistaken as right-shift insertion! (C++11 fixes it). Fix was to add space. > >          
        
        <numeric>
            ::accumulate, Replaces "reduce"
                Similar to ::transform(), but returns a single value instead of writing in another container.
                (Begin iterator, end iter, type defaultValue, functionAppliedPerElement)
        <ranges>
            Functions dealing with ranges of addresses (used by contaienrs! Return iterators)
            std::ranges::begin(), ::subrange
            Made into a library so they can be used even on non-ranged collections (cstyle Arrays, std::array)
            ::to<containerType>()
                Convert container to another type (ex: Array to Vector)

        <functional> To manipulate functions and their parameters. 
            std::bind(&funcRef, argsN, ...) 
                Generates a function object.
            std::placeholders::_N //(1,2,3...) Used as an argument in std::bind. Placeholder is stored in func object as if declared with "extern" keyword (linked globally). _N replaces the Nth element when a function is called with UNBOUND ARGUMENTS. 
            std::function - Wrapper for invokable objects (that can be called like a function): functions, functors, lambdas. Can store funcs in objects (like vectors). Tells the program " you can interact with this thing as you would with a function " (Interface)

STL COMPONENTS
    CONTAINERS
    std:: vector, list, map
    <vector>
    Arrays with various properties (dynamic, key:value relation, ordered or not...)
    
    ALGORITHMS
    <algorithm>
    Sorting, searching, manipulating data.
    ITERATORS
    Objects used to traverse containers


BUFFER
    Input-Output systems. 
    Smaller, fast memory component between CPU & Main memory.
    Temp space used to store data while it is being transferred between different parts of a program or between the program and external devices.
    Store data in a buffer, use it, empty it. Waits before operation is finished before sending data: prevents extra read/writes
    "Buffer Overflow": More data than its size allows.
    "Flushing": Operation to send out data from the buffer in that state (used w/ std::cout/cin to ask for user input with a phrase)

OPERATIONS/OPERATORS

Unary, Binary, Ternary (operate on 1, 2 or 3 operands)

SEE THIS PAGE FOR A TABLE https://en.cppreference.com/w/cpp/language/operator_precedence
EXTRA INFO https://en.cppreference.com/w/cpp/language/eval_order


INCREMENT/DECREMENT
    varName++ varName-- and ++varName --Varname (prefix vs suffix expressions)
        Prefix returns value (expression is evaluated) AFTER incrementing.
        Postfix returns value (expression is evaluated) BEFORE incrementing.
        Prefixes can be chained: ++ ++a



ARITHMETIC
    + - * / (integer division, quotient) % (modulo, remainder)

BITWISE Booleans: bit-by-bit between operands. NOT LOGICAL OPERATORS.
    & (ampersand) Bitwise AND, | (single vertical bar) Bitwise OR, ~ (tilde) Bitwise NOT , caret ^ bitwise XOR
        Bitwise: each bit is considered independently.
        (2 & 5) is False, because 00000010 and 00000101
    << >> left/right shift

LOGICAL (Booleans):
    %%, && AND, || OR
    "Short-circuit evaluation" &&
        If first part of the statement is false, doesn't even check 2nd part.
    ! NOT operator inverts its operand. If any other data 
    No Logical XOR because of Relational !=. XOR returns true if both values are the same (false false or True True). So a!=b, with a= true and b=false, is the exact inverse of Logical XOR : false false & true true both return FALSE, while false true & true false both return TRUE.
        ONLY FOR BOOLEANS
        For NonBools, must convert them to bools first. Because we don't care in a XOR specifically if both values are inverted (we would care if one is) then we can use it to convert that data type to a bool (0 would become true, everything else would become false).
        if(!a != !b) {}
        Notice how it's the same as a!=b but also works for non-bools.

COMPOUND ASSIGNMENT
    =, +=, -=, *=,/=, %=

COMPOUND BITWISE ASSIGNMENT
    <<=, >>=, &=, ^=, |=    

COMMA OPERATOR , -     

RELATIONAL https://en.cppreference.com/w/cpp/language/operator_comparison
    >, <, >=, <=

    Equality: == !=
        (do not use = in a conditional, as it returns the assigned value: a = 5 returns 5, a == 5 compares if a is equal to 5)    
    Do not use these with Zero. Any statement resulting in 0 == False in CPP (implicit boolean). Anything not 0 will be True. So you can safely use 
    if(a%2){//code for True (remainder, a is Odd)} 
    else {//code for False (no remainder, a is Even)}


    Three-way <=>

TERNARY OPERATOR / CONDITIONAL OPERATOR
    conditionExpr ? ifTrue : ifFalse - Shorthand of if/else statements. Expressions in all 3.
    Definition of ternary: "Takes 3 operators"

    Can chain for multiple if/else (Ternary operator can be part of any of the 3 expressions). Gets unreadable quick when nesting.
        std::string difficulty = (choice == 1) ? "Easy" : (choice == 2) ? "Medium" : "Hard";
    Use parentheses to clarify expressions. For humans, not compiler.

ACCESS
    OPERATOR - SCOPE RESOLUTION ::  Calling Functions from libraries is done by calling members of a library
    Scope is where the function/variable is accessible in the code, so you're telling where to find the object (here, defined in library)
    member::object
    (see Enum Classes - :: is used to access the single 'enumeration' object.)

    OPERATOR - MEMBER OF . (dot)
        To access a member of an object


POINTER: These have a single operand, nothing to the left of operator.
    Prefix * : 
    Prefix & : Address of variable at its right (
    -> Arrow : access to members of classes or structures from a pointer



    OPERATOR - MEMBER OF POINTER ->
        Similar to Member Access, but follows all pointers until it finds an object, and accesses its member.

    OPERATOR - ADDRESS OF & Returns the address of a function (optional) or variable.

    OPERATOR - DEREFERENCE/INDIRECTION * Dereference Pointer (of variable to its right) 
        Gives access to the variable it's pointing to. Ceases to be a pointer

    OPERATOR - POINTER-TO-MEMBER .*, ->* - Combines operators to get the pointer of the member.    

DATA
    OPERATOR - (LEFT BOUND) INSERTION << Data can be inserted into Object (instance of class) to their left using this. 
        Takes care of converting from int/float to string when inserting in ofstream (fstream) and cout (iostream).

    OPERATOR - (RIGHT-BOUND) EXTRACTION >> Data is extracted from an object and inserted into variable/object to the right.

MEMORY ALLOC
    Dynamic Alloc new, new[] - Dynamically assigns memory for object. Accessed using pointers.
    Dynamic Dealloc delete, delete[]
CAST
    Functional Cast - type(), type{}

    Static Cast - (type) CStyle

SUBSCRIPT
    a[] -  Accessing sub-addresses of arrays, typically through indices  


UNARY
    Plus/Minus +a -a - The sign to define if argument is positive or negative.

KEYWORDS
return();
A keyword to output a value from the function, ending it.
0 is traditionally "no Error". Ex: 404 meaning "page not found"
Can use parentheses around returned value or not: 
    return(value) or return value


switch(value){
    case a:
    //code
    break;

    default:
        //code triggered if no conditions match
}


FLOW CONTROL
if (condition){//code)}

do/while loop:
BEFORE IMPLEMENTING : CHECK IF ALGORITHM CAN DO IT.
    MUST ensure the loop can succesfully runs at least once (it is run once regardless) (Does the body, then evaluates.)
    Example iterating through elements of a  vector by index:
    i=0
    do {
        //code 
        i++
    } while(i < vector.size());

    USE CASES:
        Initializing settings, displaying a menu


while loop 
BEFORE IMPLEMENTING : CHECK IF ALGORITHM CAN DO IT.
    while(condition){//code}
    If condition is immediately false, then it won't run at all. (see do/while) (Evaluates, then does the body if TRUE)

    Can use pointers/iterators to loop through all elements of a vector.
    vector.begin() = iterator pointing at first element
    vector.end() = pointer past the last element
    next() = RETURNS the next pointer (you must assign it if iterating through container!!)

    auto pointer = vector.begin();
    while(pointer != vector.end()){
        //code
        pointer = next(pointer,1);
    }

    EXAMPLE: Keep asking for a valid input until it's correct:
    std::string playerName;
    std::cout << "Enter your character name (must be non-empty): ";
    std::getline(std::cin, playerName); //Similar to extracting from cin, but supports more than 1 word
    while (playerName.empty()) {
        std::cout << "Character name cannot be empty. Please enter a valid name: ";
        std::getline(std::cin, playerName);
    }


for loop 
BEFORE IMPLEMENTING : CHECK IF ALGORITHM CAN DO IT.
    for()
    When you know the range in advance. Can also use a while loop.

    for(initialization; condition; increment){
        //code
    }

    for loop with Iterator: ("ranged" or "range-based", bc arrays are ranges of addresses)
    //WARNING:If you use variable of the same type as the element of vector/array, the element will be COPIED in the variable, each iteration. Use references instead. (& in example below)
    /
    for( type iteratorVariable& : containerToTraverse){
        //code
    }
                    Also called (elementVariable : sequence)
    Supports initializer_list as type for 2nd argument! for (int n : {1,2,3,6}){} //valid
    Strings are collections.
    Can work with Maps to print all values


    Non-Ranged Collections: Do not support the <ranges> C++20 library (.begin(),.end())
        c-style Arrays
        std::array
    Must specify namespace of begin/end functions to call them (std::ranges::begin(), ::subrange
        
    For each loop
    std::for_each(iterator_start, iterator_end, unary function reference)
        void print_this(const int &n){ std::cout << "-" << n;}
        //main
        std::vector<int> nums{3,4,2,8,15};
        std::for_each(nums.begin(), nums.end(), std::bind(&print_it, std::placeholders::_1));
        //OR PREFERABLY (if used once)
        std::for_each(nums.begin(), nums.end(), [](const int &n){std::cout<<"-"<<n;});
        //OR PREFERABLY (if used multiple times)
        auto myFunc = [](const int &n){std::cout<<"-"<<n;};
        std::for_each(nums.begin(), nums.end(),myFunc);


GENERIC PROGRAMMING STYLE
Reusable code where dataTypes are NOT specified - the instance defines the data type. 
"Compile-Time Polymorphism": 
Data types specified at var definition OR object instantiation -> Polymorphism resolved at compile time.
"Run-Time Polymorphism": A traditional approach.

CLASS TEMPLATES <Type> 
Constructs that take on a type at compile time, instead of being specified.

SYNTAX: 
template<typename T> //both template and typename are keywords. T is now a placeholder type: Whatever variably it's given, "a" in the example below, it'll take on the corresponding type, automatically. Compiler handles the variants needed.

int size_in_bits(T a) {
    return sizeof(a)*8;
}
//Now valid:
size_in_bits(21)
size_in_bits('f')
size_in_bits(2.0f)


std::vector a; //Does not work - what type of data does the vector contain? Not a type by itself.
std::vector<int> a; //Correct declaration.

Templates can be used in class Constructors to make input types versatile without rewriting code.
Data members must also be of "template type".
Want to set a position? 
Integer, Float, Double, Strings - all will work. Though finding a common constructor code to fit it all could be harder. 
    You CAN Overload for specific types in addition to template: will be preferred over template.
Implicit conversions are applied unless "explicit" keyword used before Constructor.
        struct MyClass{

            MyClass(int val):value(val){} //Constructor

            // Conversion operator in MyClass : Overloads implicit and explicit conversions to integer
            operator int() const {
                return value;
            }

        }
        int main(){
            myClass obj(42);
            // Implicit conversion using the conversion operator
            int x = obj; //Saying type x= Something means "implicitly convert this to an integer if it isn't"...
            // Explicit conversion using static_cast
            int y = static_cast<int>(obj);  //Only works because of Operator overload
            }




INTERFACES
An interface is "a promise to implement a function". A class can implement an interface. A function allows to check if a given class implements an interface.
    ITERATORS
    Iterator interface - supporting it can let you work with iterators for your own data types (range-based for loops, algorithms)

STL : STANDARD TEMPLATE LIBRARY
Library of templates, typically included in Standard Library (STD).

ALWAYS USE FUNCTION IF IT EXISTS.
for loops that simply increment a variable? std::accumulate()
filtering? std::copy_if
modifying the entire array with a function? ::transform()

4 COMPONENTS
    CONTAINERS: store collections (array-like) of data (vectors, stacks, queues)
    https://en.cppreference.com/w/cpp/container
        Sequence: Storage in a Linear sequence
        Associative: KVP (fast look-up, insertion, deletion)
        Unordered Containers: Similar to associative, but order is not maintained
        Adapters: (Not containers) Behavior modifiers of containers for different interface

        SEQUENCE: 
            Vectors <vector>: Dynamic, fast random access (fetch any element without going through previous ones), resizable. push_back
            Deques <deque>: double-ended queues (insert/delete at both ends) push_front + push_back
            Lists <list>: doubly-linked list, fast insertion+deletion from anywhere in list. NO random access
        
        ASSOCIATIVE:
            Sets <set>: Ordered, unique elements
            Pair <utility>: class storing 2 different objects as 1 unit. Not a container. .first, .second
            Maps <map> : Dictionaries (KVP). "Set of pairs" : unique keys singularly-linked with values

        UNORDERED CONTAINERS: Equivalent objects but not ordered; faster to search/insert/delete (look-ups)
            unordered_map
            unordered_set
        
        CONTAINER ADAPTERS: Modify the behavior of containers
        (Underlying "deck" container, but can work with a vector or list)
            Stack <stack>:Last-In-First-Out //Menu states or game states that go down a branching/tree structure
                std::stack<datatype> ; .push() .top() .pop()
                    .top returns last element added.
                    Backtracking or Undo operations!
            Queues <queue>: First-In-First-Out
                std::queue<datatype> ; .push() .front() .pop()
                    .push adds to end of the queue. .pop removes First element.
                    Event queues (things always happening in order, one after the other)
            Priority Queues <queue>: Sorted order of elements.
                std::priority_queue<type> ; .push() .top() .pop()
    
                    FOR POP functions : make sure the container isn't empty (!container.empty()).

    ITERATORS
    Objects similar to pointers to traverse containers efficiently and manipulate them generically
        Templates at their core.
        Iterators are addresses, and can therefore be dereferenced like pointers. 
        POINTERS VS ITERATORS : Subset and Superset
            Pointers: 
            Variables that can be indirected to refer to memory location. Part of what many iterators do, so pointers are a type of iterator.
                EX: Using integer indexes in arrays: variables that can be indirected to refer to a memory location. Doesn't make all integers iterators, but in that context, they are.
            Iterators: 
            An abstraction of that concept - an element to traverse containers (pointers: variables to traverse the "memory" container. Not all containers.)
            Requirements for object to be an iterator : 
                Input iterator - Read one-way, one-pass (read-only, forward only, traversing container twice won't give same result... UNORDERED??)
                    Uses: input streams (keyboard buffers, read-only files)
                Output - Write one-way, one-pass
                    Uses: output streams, writing to write-only files
                Forward - Read/Write one-way, multi-pass
                    Read/Write = Mutable (writing specifically)
                    Only moves forward
                    Multi-Pass
                    Uses: Singly-Linked List. By linked, means they have information necessary to move to the next element.
                    forward_list, unordered_[multi]set, unordered_[multi]map 
                Bidirectional
                    Forward, + Forward/Backward traversal (doubly-linked list). 
                    Uses:
                    list, [multi]set, [multi]map
                Random Access
                    Bidirectional, + random access (indexing). Not only are they linked, they are also indexed ("list" outside of elements?)
                    Uses: Vectors, deque, (arrays)

        Generic Iterator Functions:
            MEMBER FUNCTIONS of containers
            .begin() : iterator to beginning of container
            .end() : to end of container (past the last element)
            .rbegin() : reverse iterator to the last element of the container (first of the REVERSE container) (not impl. in Forward iterators)
            .rend() : iterator to the reverse end of the container (element right BEFORE first element) (not impl. in Forward iterators)
    Algorithms: <algorithm> search, sort, modify, count
        sort(iterator to starting element, iterator to end element, (opt) bool ) //Start and End are arguments, you can sort PART of a container. Iterators already point to a container, a memory space, so no need to pass the Container as argument!
            Default Sort: STD::Less (C++20)
            Sorting w/the reverse iterator = inverting the Sort
            Sorting w/ a 3rd parameter : functor, resulting in bool. If true, evaluated data takes the slot (using "greater<int>" would sort from highest to lowest, because it checks if 1st element is higher than 2nd. 
        find(start iterator, end iterator, value to find) // First occurence. Returns iterator to object, or to .end() if it can't find it.

        count(start iterator, end iterator, value to count)


    Functor(Function Objects): <functional> Overload parentheses, they maintain states and can be parametrized
    Objects that can be used as if functions, by using ().
        Overloading () operator!
    They are objects (instances of classes), so they can hold data (maintain states)
    #include <iostream>

    // Functor class Example
    class MultiplyBy {
    public:
        MultiplyBy(int factor) : factor_(factor) {}

        int operator()(int value) const {
            return value * factor_;
        }
    private:
        int factor_;
    };

    int main(){
        MultiplyBy multiplyBy5(5);  // Create a functor with factor 5
        int result = multiplyBy5(10);  // Calls operator() with value 10
        std::cout << "Result: " << result << std::endl;  // Output: 50
        return 0;
    }

    //The simplest functor: class that can be called with () operator.
    class functor{
    public:
        void operator()() const{
        }
    };

        USE CASES
        Keeping a state
        Algorithms where function pointers would be used (+ flexible, + potential optim)
            
    Lambda Functions
    Alternative to Functors : (can't maintain state)
    Becomes an OBJECT (as any function call) on the Stack. Compiler defines it as a class, captured vars become data members, it's instantiated at runtime.
    Inline unnamed functions that can "capture" variables at their scope.
        CAPTURE 
        
        All variables can be captured using:
        By Value : [=] All variables. [varName] A specific Variable. 
        By Ref : [&] All variables used  
        With Initializer [ a = expression ]
        List : [ a, b]
         
         https://www.learncpp.com/cpp-tutorial/lambda-captures/
    SYNTAX
    [captureClause](arguments){//body}

    USE CASES
    One-Off operations, arguments to algorithms. Avoids having to define function with a name outside of its intended use-case (makes it easier to know that the function is for that one line only)
    Local Scope operations

EXCEPTION HANDLING
Exceptions caught by these statements interrupts flow of the program to execute code within those blocks.

try{} //Contains statement that could throw an exception
catch(const exception_type& var){} //Code that handles the exception thrown by Try. Use refs!

throw exception_type("String to explain exception") //Statement to signal occurence of exception.
    EX: throw std::invalid_argument("Division by zero is not allowed."); //the string will be returned by .what()
    Try{}/Catch(){} must still be used to catch it!

.what() //Member func, displays string based on exception declaration. Typically used with the catch's var and inserted into std::cerr, object used to display error strings on the console. 
    EXCEPTION TYPES
    std::runtime_error : files not found, 
    std::invalid_argument : Dividing by 0
    std::out_of_range : [2] on an array with <3 elements

    BEST PRACTICE
    Make sure to release resources if Exception occurs.
    RAII principles (Resource Acquisition Is Initialization), Smart Pointers to help.



FUNCTIONAL PROGRAMMING STYLE
C++ is NOT a functional programming language, so this is a style. (guidelines)

Immutable vars (supports multithreading)
Recursion prefered over Loops (bc vars are immutable!)
Functions: Pure and simple (Outputs depend STRICTLY on their Inputs. No side-effects bc they do not modify state of the program.)
    STATE: External Resources, open Files, stack, heap, values of variables, location in program's code that's being executed AKA Program Counter
Simple debugging/testing
Expressions preferred over statements (return values) (statements return nothing, used for side effects)
Currying: manages how args are passed to functions
    CURRYING:
    Partial Applications: 

    C++17 FEATURE: NESTED NAME SPACES
    namespace A::B::C {
        int i;
    }
    int main(){
        A::B::C::i = 42;
        //print value in cout
        return 0
    }



    PREDICATE
        An UNARY function that returns a BOOL value.

    _BoundArgs: input arguments of a function.



    BINDING & PARTIAL APPLICATION
        std::bind, <functional> header
        Creates a new function, less arguments, from another one, by "binding" (attaching, setting) values for all but one of its arguments.
        ARITY : # of arguments(operands) a function accepts. AKA Unary, Binary, Ternary.

        PARTIAL APPLICATION: Fixing a number of arguments of a function.
        Can partially apply functions, reorder their arguments and bind values to arbitrary arguments.
        Ie. Can reduce a functions Arity from binary (two arguments) to unary (1 arg) when a predicate (see above) is needed.

        Non-Functional Programming: 
        EX:Iterating over vector of values, incrementing results.
            "Over 21" - how many numbers over 21. vector, int over21 = 0, increment it in a for-loop.

        Functional equivalent:
            bool greaterThan(int a, int b){ return a>b;} 
            auto num_over21 = std::count_if(vector.begin(), vector.end(), std::bind(&funcGreaterThan, std::placeholders::_1, 21));
            
            //Binds a binary function, greaterThan, to an unary function object, using its single argument as its 1st, and 21 as its 2nd argument.
    
    WRAPPING
        Class template
        "Wraps" a reference , binding together the data + Functions to manipulate data (AKA Encapsulation)
        std::function
            std::vector<std::function<returnObject(args)>> varName;
                std::vector<std::function<void()>>  funcs;//RETURN TYPE MATTERS, NOT ARG TYPES: returns void from the invokables that this vector takes. Must match input types... but can bind that issue away. 
                    funcs.push_back(invokableThatReturnsVoid)

LAMBDAS
    Unnamed function Object 
    Creates a closure over calling scope 
        CLOSURE - any func that closes over environment in which it was defined (as opposed to ONLY its own calling block). 
            CAPTURES - the act of taking those variables in. 
    When compiler goes over a Lambda, it converts it as an anonymous "closure object", AKA a Closure.
        As if defining a class that fetches data from a scope and stores it, letting itself access the data after being instanced. 

    Prefer LAMBDA EXPRESSIONS over std::bind()

    Class -> Instance of a Class (Objects) 
    Lambda -> Closure
    // Code-Only -> Runtime
    //Classes and Lambdas = Code Memory
    //Objects and Closures = Data Memory

    mutable keyword - can be used to make changes to Closure.

    CURRYING
    Transformation of a function w/ Multiple Arguments into a sequence of Unary functions.
    
    nested lambda -> 
    auto addCurry = [](auto a){
        return [a](auto b){
            return [a,b] (auto c){
                return a+b+c;
            };
        };
    };
    By returning a CLOSURE (FUNCTOR), you can do a sequence of operations:
    auto added1 = addCurry(1); //Returns the [a](auto b), closure which captured a (1).
    auto added2 = added(2); //Returns the [a,b](auto c) closure, which captured both a(1) and b(2)
    auto addResults = added2(3) //Returns a+b+c, totals 6

    Can do them all in a single line as the order of operations just goes through 1 by 1:
    auto allAtOnce = addCurry(10,20,30); //Returns 60

    LAMBDA MUTABILITY
    Lambdas' captured variables are, by default, const. This is to ensure they match whatever they captured!
    Can break this using "mutable": []()mutable{}

    This lets you nest lambdas:
    auto incrementer = [](){
        auto increment =0
        return [increment]() mutable{ 
            return increment++;
        };
    };

    Here, the first CLOSURE is holding the "increment" var value. The 2nd closure "references" (captures) that value WHEN CALLED, and increments it.
    Initialization is effectively done w/ the first Lambda, and implementation in the 2nd.


    Lambdas & Switch (statements -> expression)
        auto a = 0; //Could replace this with an enum
        const auto myFunc = [&](){ //capture all variables at scope as references
            switch(a){
                case 0:
                    return 5;
                case 1:
                    return 23;
                default:
                    return 1;
            }
        };


VARIADIC TEMPLATE FUNCTIONS
    C language initially
    Functions with any number of parameters.
    EX: Reverse Concatenation (recursive)
        template<typename T> //The function overload that stops the recursivity
        T rcatenate(T v) {
            return v;
        }

        template<typename T, typename... Args> //typename ... Args means any number.
        T rcatenate(T first, Args ... args){ // Args ... args == Parameter pack, or "the rest of the arguments". IMPORTANT: NO TYPE for ARGS!
            return rcatenate(args ...) + " " + first; //When called, "first" receives first argument. Then called again, until it hits overload 
                                                        w/ 1 parameter left.

    Sets "template parameter packs", ie. independent combinations of typenames
    Types can be different
    REQUIRES a base case w/ 1 parameter.
    Variadic functions exist, but prefer Variadic Template Functions.

TEMPLATE METAPROGRAMMING (TMP) - Generic Programming Style?
    Turing complete functional programming language built in C++
    TMP Vars : Immutable
    No Loops. Recursion instead.
    No Branching. Specialization instead.
    No Return statements.

    Generic programming vs Template Metaprogramming:
        template<typename T>
        T cube(const T& value){
            return value*value*value; //not modifying the value, only returning its cube
        }
        int value = cube(8);
        //This cube function is instantiated & called at runtime.

        template<dataType immutableName> //Template PARAMETER of a fixed type, instead of using typename for a flexible-type template. Typename == Class, no difference... a class can be used as a type.
        struct Cube { //Class but public
            enum { value = toCube*toCube*toCube //Why an enum? It is a STATIC value (1 instance of member, can be accessed without an object...bc computed at compile and allocates memory at program start)
            };
        };
        int value = Cube<5>::value; //Creates a struct with a member value initialized at the cube of the input, at COMPILE TIME.

        //This Cube function is reduced at Compile time.

    Comprehension: Quand Template est utilise, dit a l'ordi "compile-moi une variante pour chaque utilisation differente".
    Si Typename/Class, a chaque nouveau type requis par le code (int/float/personnage/bande-dessinee), cree une classe qui le supporte. 
    Si type defini, pour chaque utilisation du template, compile moi sa valeur (devient une constante). ex: <int a> va creer des constantes avec chacune des utilisations.

    Dans le cas d'une enum qui utilise la constante, une enum (variable statique) est creee pour chaque template: non seulement "a" cree des constantes, mais la struct qui en depend est compilee pour chaque variante. Dans le cas de "cube", le resultat de a*a*a est compile pour chaque a.
    Declaration simple: la valeur de  l'enum est a*a*a
    
    Cas Recursif 1: Factorial
        Une struct Factorial est definie par l'heritage d'un parent de type Factorial<template parameters>.
        Pourquoi? Premiere Factorial est compilee: besoin d'un autre template. 2e est compilee, et ainsi de suite.
        A chaque instance, l'operation sur les PARAMETRES est effectuee : Factorial<n-1,n*sum>
            n-1 s'effectue a chaque template compile, jusqu'a ce que la specialization "1" soit atteinte. 5 devient 4, puis 3, 2, 1
            n*sum est le resultat recherche - 5*4*3*2*1 ou chaque multiplication est un template subsequent.
            Meme pas besoin de stocker de valeur! n s'en charge. 
            Seule la specialization a besoin de stocker la valeur, qui est simplement "sum" 

        Specialization est requise pour finir la recursion.

    Cas recursif 2: Fibonacci<n>. La premiere structure compilee determine qu'elle a besoin de 2 autres Fibonacci, fibonacci(n-1) et fibonacci(n-2). 
        Ici, la valeur stockee ne definit pas le prochain template.
        Les instances recursives de Fibonacci sont definies dans la valeur elle-meme:
            fibonacci<n-1> et fibonacci<n-2>
        Le compilateur continue recursion jusqu'aux specializations, soit fibonacci<1> et <0>, pcq quand Fibonacci<2> est construit, il demande <1> et <0>. 
        Eux retournent une valeur fixe, plutot qu'une nouvelle instance de Fibonacci. Toutes les instances de Fibonacci crees pour se rendre la peuvent donc etre calculees: 0+1, puis 1+1, puis 1+2, 2+3, 3+5, etc.

    SPECIALIZATION
    Templates are called similarly to function overloading: If a specific case exists, it takes priority over generic case.
    
    EX:
    template<int input, int sum = 1> //Generic Case
    struct Factorial : Factorial<input-1, input*sum>{
    }; //Infinitely Recursive : Factorial calls itself forever.

    //Solve the problem: SPECIALIZATION.
    //Overloads of function templates. Replaces "if input == 1" by giving Factorial a different implementation when that input combination occurs.

    template<int sum>
    struct Factorial<1,sum>{ //Specific Case to exit recursion.
        enum {
            value = sum
        };
    };

    REACTIVE EXTENSIONS
    ReactiveX : combines observer and iterator patterns.
    All major prog languages.

    4 Keys:
        Observables - Composable streams of events
        Observers - Those interestred in events
        Operators - Functions that manipulate Observables
        Schedulers - Execute actions associated with operators.
    
    RxCpp - Header-only, C++ implementation of ReactiveX (clone from Github)
        #include "../../RxCpp/Rx/v2/src/rxcpp/rx.hpp"
        Tutorial used namespaces: 
        namespace Rx {
            rxcpp, rxcpp::sources, rxcpp::operators, rxcpp::util
        }
        using namespace Rx;
        std::vector<int> ages{9,20,13,4,5,6,10,28,19,15,60,23,47,12,19,99};
        auto values = rxcpp::observable<>::iterate(ages). //dot is for "chaining interface", or "fluent interface"
         filter([](int age){return age >= 21;}). //Returns list of values over or equal to 21
         count(). //Counts how many in list
         subscribe( 
            [](int count){std::cout << "Numbers over 21 = " << count << std::endl;},//for each event, the first method occurs
            [](){std::cout << "OnCompleted" << std::endl;}//Method called when observable is complete. Returns OnError if it fails.
         );

        auto values2 = rxcpp::observable<>::iterate(ages). //dot is for "chaining interface", or "fluent interface"
         filter([](int age){return age >=13 && age<=19;}). //Returns list of values between 13 and 19, inclusive.
         subscribe(
            [](int age){std::cout << "Number between 13 and 19 incl. = "  << age << std::endl;},//for each event, the first method occurs
            [](){std::cout << "OnCompleted" << std::endl;}//Method called when observable is complete. Returns OnError if it fails.
         );


    STL Containers conversion to Observables
    Chaining or Pipe Interface:
        - .

