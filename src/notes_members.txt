
VARIABLES
Temporary data storage units. Must be declared prior to usage.
Declaration can contain initialization.
varType varName;
Can use types defined in libraries, std::string (check "std" for token "string")

Can declare multiple at once using commas, initializing as needed:
    int a, b = 5;

    CONSTANT LITERALS
    A value in your code that doesn't change.
    Examples:
    Numbers: 10, 3.14, 0, -5
    Characters: 'a', 'Z', '!'
    Strings: "Hello, world!", "This is a string"
    Boolean values: true, false

        CONSTANTS : named values representing a fixed value (PI)
        LITERAL : a fixed value (5)

COMMON DATA TYPE LIBRARIES : STRING STANDARD LIBRARY
    
    #include <string>

    INTEGERS
    stdint.h header file from the C library.    
    Made into C++. Name had a c added as prefix: <cstdint>
    Size is implementation-dependent:
        uint32_t
        int16_t
    U = unsigned, int = integer, number = bit size, _t = type\
    Signed = positive & negative. 
    long = larger, 64bit ints
        If you subtract an unsigned int below 0, it'll use the complement representation in binary: 4294967296 (2^32), i.e. starting from the other end.

    Integers = int, with an optional Radix (la base du nombre, base 8 base 12 base 16). default = Decimal, no radix specifier
    -5, 123, etc.
    Leading 0 = Octal (base 8) (ATTENTION)
    0x = Hexadecimal 0x10 (16) <--- Often used for bits, as 4bits = 16 (2^4)
    0b = Binary (1001)
    Trailing (suffix) U = Unsigned 23U   

    CHARACTERS
    char(8bits), 'h', '7', '\n' (single character), '\0'
    Can be entered as small integers (fitting in 8 bits) or as ASCII between single quotes = 'x'
    Backslash = escape character 
    '\0' == Null character, delimiting the end of a string
    '\n' == new line character



    BOOLEAN
    bool
    true, false
    Anything except 0 is true (implicit bool)



    FLOAT
        Float literal = Trailing f = 23.05f
        double: default = 25.4
        long double = 3.12130192435409L
        At least 1 decimal, even if 0.0f

        Implementation defines min/max of what they represent.
        Follows standards like IEEE 754 https://en.wikipedia.org/wiki/Single-precision_floating-point_format
        https://stackoverflow.com/questions/14221612/difference-between-long-double-and-double-in-c-and-c 

    STRINGS
        Requires <string> STL (Standard Template Library)
        "string"

VARIABLE MEMORY

Variables are declared at a specific scope.
    Global variables : managed statically  by compiler, held in memory until program is exited in the Data segment of memory.
    Local variables : within a given scope, held in memory as long as program remains in that scope.
        Exiting the scope == variables deleted from memory.
        Scope can be determined by {} : functions, classes, etc.
        "Automatic variables" == managed dynamically by compiler, allocated in the Stack segment of memory, which itself is temporary.

Type Inference: must initialize at declaration, but compiler infers the type of the variable.
    auto a =1, b = "", c = 'c', d = 3.14f, e = 12345678901, f = 3.14, g = true
        a = int32, e exceeds 32bits, so long int
        d = float, f = double
        g = boolean

Getting the Type:
typeid(varName).name()
    typeid is implementation dependent. Compilers will change the output... some more descriptive than others. Might be int or double, instead of i and d. Or even an error.
    name is a member function of each type.
i = int, l = long, f = float, d = double, b = bool, c = char, PKc (pointer to const char) = string

Shorthands:
Modifying variable, setting it    
    varName = varName + 2
    varName += 2




DATA TYPES
Representations encoded in bits that vary in length. 
cppreference.com/basic concepts/types
Primitive Types: basic category, without defined implementation (ex: int is primitive, vs uint32_t)
Portable Types: types that can be ported to different systems, because they are always declared and compiled with the same properties (behavior and size).  sdtint.h (library) defines fixed-width integers using the ISO C99 standard: int8_t (signed 8bit int) , uint32_t (unsigned 32bit int)

Fundamental/arithmetic/compound : https://en.cppreference.com/w/cpp/language/types
Complete/Incomplete: Wether it has all information required to define a space & layout in memory. This can apply to classes, data types, objects,  
Constant, Volatile:

    VOID
    Fundamental Type, empty set of value.


    INT (integer, variable # of bits, its length, based on implementation... generally 32bits, can be 16)
        SIGN / UNSIGNED
        Refers to the Positive/Negative split: signed 8-bit integer ranges from -128 to 127
        Unsigned ranges from 0 to 255.
        Sign is stored in the left-most bit (also called MostSignificantBit, MSB), typically the largest part of the value of the number
        
        Instead of using stdint.h library w/ ISO C99 standard, can declare them:
            unsigned int varName;
        
        Negative values loop back to the highest if stored in an unsigned variable; -2 will become 4294967294 
        It is equal to 2^32 -2, the "complement representation" in binary: exact same binary, but different interpretation.
    
    FLOAT (floating-point numbers: Real numbers) using IEEE754 binary floating point Standard
    Float
    Double : more precision and range, but computationally intense
    Long double

    BOOLEAN (true/false)
    bool
    In C++, {true,false} are defined as keywords for it. 0 = False, everything else = True

    CHAR (character, 8bits)
    ASCII as a byte. Can be used as an integer...

    STRINGS
    Not native to C++
    Arrays of characters (char type), terminated with value 0 (null character)
    std library has it as a Class: <string> header includes the class and functions to manipulate the Class/data.
    <cstring> : header from the C library with functions to manipulate strings.

    String class should be used instead of character arrays... but if code NEEDS to be compatible w/ C, then we can use character arrays and import the <cstring> library to get the functions to achieve the same results as the C++ <string> header offers for its string class.


    POINTERS
        Data type for memory addresses. System architecture (32bit, 64bit, 96bit) dictates maximum memory size of the pointer, ie. the full precision that data could ever be located at. Pointers will use X Bytes, depending on what they need to contain.
    Memory Map:
    Location (address), Unit (content)
    1 address per byte.
    32bit data (ex: int32)  == Each unit is 4 bytes

    May act as references to variables.
    Pointers have a type: int&, float&, string&...
    Can be used to access multiple different variables sequentially.
    
    Can also be VOID or NULL to point to any function or object requiring these.

    Nullptr = a pointer of type nullptr_t (distinct type that is neither pointer nor member type). Defined in header <cstddef>, std::nullptr_t

        Symbols:
        dataType *ptrname;  (* == Indirection operator; "consider this an indirection")
        "ptrname points to a" (colloquial)

        ptrname = &a; (& == Address Of)
        

        *ptrName will return whatever is contained at the "pointed" address, in this ex., the value of a.

    Addresses will look like "0x7fffffffffde40"
        MAIN USE OF POINTERS : DYNAMIC MEMORY MANAGEMENT
        Allocation of memory (malloc functions) to create and remove data at runtime, instead of strictly at executable startup
        Called by constructors.

        ex: When creating an instance of class cow: 
            cow *my_cow;
            my_cow = new cow(constructor args);
        
        Q: Why is a pointer required here? 
        A: Because the variable is not at a static location on disk; it's somewhere dynamic. We can't ask program to predict it, and we do not want to reserve it.
        So we ask the program to create an address of type cow, then we tell program "create a new instance of what follows at this address".
        
        To use pointed data, *ptrName. 
        To access members of a class, basic way is: (*ptrName) to prioritize dereferencing the pointer in the sequence of operations.
        However, messy if trees and lists... Dedicated OPERATOR - MEMBER OF POINTER ->
        DESTRUCTOR
            delete varName;
            This keyword calls the destructor function of a class and removes it from memory.
        SMART POINTERS
        To prevent "dangling pointers" and memory leaks.

        FUNCTION POINTERS
        returnType (*funcPtrIdentifier)(args[..]);
        funcPtrIdentifier = &funcName; //& optional. Address of Function.
        You can call a function through its address.


        POINTERS TO ARRAYS 
            int (*) 32 //Type "pointer to an array of 32 integers"

    REFERENCES
    type& name = memberToReference        
    Simple rewiring of tokens
        Not Pointers, nor objects, nor address (no array of ref bc no address)
        Always initialized (guarantee of finding data)
        1 Ref = Alias to a single object (at declaration)
        Single level of indirection, ever.

        USAGE OF REFERENCES:
        Passing parameters by ref (instead of by value)
            Allows modifying the argument variable directly within the function
        Avoiding Copies. Function parameters are typically copied. If large object, you do not want to unnecessarily copy it. 
        Optimizing ForLoops by avoiding copies each iteration.
            A form of for loop uses variable to iterate through a container. This variable MAY require copy each iteration.

    STD (STL: standard template library) VECTORS (instead of ARRAYS)
    Dynamic Size
    Memory-managed (unless objects within vector are manually allocated)
    Template - Generic container class (can implement for any type of element)
        Member functions to manipulate them
        Part of C++ STD library (generic programming style?)
        Iterators can be used (container): vectorName.begin() // iterator to the first element. .end() last element+1. Can do (instance.end()-1)->memberFunctionName, or prev(iterator, positionsToMoveBack
        Template<type>    
    Consecutive in Memory: Can only add items from the back end (furthest)
        Indexed beginning at 0 : instance[2] returns the third element.
        
    Vector Header:
        std::vector<type> vectorName;
        vectorName.push_back() // To insert elements.
        vectorName[index] = value // To set elements.

ITERATORS
    Used to traverse containers.
    Work like pointers (addresses); use the same Operators, such as ->
    Can be incremented or decremented to move within a given container. +1 == next element in container. Incrementing a pointer is NOT the same thing: next element in memory, not only in container.

TYPE CASTING
    Specify how to interpret data. 
    Ex: int & float are very different in their binary encoding.

    Implicit Conversion
        float VarName = 25.3; //type is defined as Float, but expression says Double (25.3f would be float). It is implicitly converted to a Float.
        int VarName = floatExpression // converts from 25.3 float to 25 int 
        uint32_t = int32_t expression // converts from unsigned to signed, copying binary value as-is but interpreting it differently (wrapping around to show the complement value; -7 converted to 4294967289. Most significant bit = 1, AKA huge number.


    Explicit (Casting) Conversion: explicitly specifying the data type of an expression, so that the compiler interprets it as such.
        Syntax: (desiredType) expression // Expression that evaluates to value you want to convert
        uint32_t uint32_number= -7; // stores binary value as complement of -7, AKA 4294967289
        (int32_t) uint32_number // this expression will result in the expected -7 if printed, unlike Implicit conversion. This is because it took the binary value but interpreted it differently, as an unsigned int.


    Important: "Constant Expressions"
    (5/9) // This expression doesn't make it to the code (which is then executed by the processor).
    Why? Because it can be evaluated when compiled. 

    From Copilot:
        This can be evaluated when compiled:
        const int cn = 2;
        std::array<int, cn> a2; // OK: cn is a constant expression

        This can not, and would result in an error:
        int n = 1;
        std::array<int, n> a1; 

        const, or constexpr keywords, both enforce the value cannot be changed at runtime.


Struct
Extern

COLLECTIONS
    ARRAYS
    (see VECTORS for dynamically-sized, memory-managed arrays)
    Collections of data, all of the same type (as opposed to structs?). Fixed Size.
    Indexed from 0 to N-1 (N = capacity of array)
    Contiguous in memory: next to each other, creating a sequential block of memory addresses
    Declaration only:
        varType arrayName[arrayCapacity];
    Declaration and Initialization:
        varType arrayName[] = {expression1, expression2, expression3};
        CANNOT use auto.
    Access (read/write)
        arrayName[itemIndex]
        arrayName[itemIndex] = expression;

    ENUMERATIONS
    List of identifiers (enumerators) that are integers.
        In C, operate in global scope... aka naming conflicts
        Limited type safety
    In C++ 11, Enum Classes (scoped enums, strongly typed enums). Encapsulation == OOP!
    Type Safety to prevent conversion between enum and int

    Non-Scoped Enums example:

    enum varName {data0, data1, data2};
    int main(){
        int a;
        a = data1; //printing this will print 1, the corresponding enumerator of the enumeration)


        int a;
        int data1 = 5; //creating a local variable in scope of main.
        a = data1; //printing this will print 5, the corresponding enumerator of the enumeration)
    }
    int c;
    c = data1; //printing this will print 1, because the value 5 was only true as part of Main. Because a is a local variable in main, main would output it first. :: could be used to define the scope and get main's value... but still a problem. data0, data1, etc. are names which do not have a scope, as they're outside all functions. Reusing the name will cause an error: redefining the same names with potentially different values. What would the program output? This is compiled, not interpreted, so it doesn't simply take the last one.

    Class Enums (scoped, strongly typed): <cstdint>?
    enum class enumName{data0, data1, data2}; //because this is now a class, the values are in the scope of that class. No need for "" for strings; they are simply tokens that can be interpreted as integers. Doing so returns the index in the enumeration, AKA the enumerator
    int main(){
        int a;
        // a = enumName::data1 (writing it like this will be an error if data1 isn't an int; that's expected (strongly typed))
        a = (int) enumName::data1 // casting as an integer

        // the alternative, preferable:
        enumName a; // this makes a variable of type enumName. It will contain 
        a = enumName::data1 // No type mismatch. To print it, we would need to cast it as another value: (int)a. It will return 1, the enumerator.
    }
    

CONSTANTS
    MACROS [Typically Do Not Use]
    macros or constant variables can achieve the same objective. Prefer const variables, as they have a scope.
    #define MACRO_NAME = 4;

        Useful as parameters in the code: size of screen, length of a memory buffer.
        Can be directives or variables.
        #define "find and replace" all of the instances of that symbol. AKA MACROS
        Can be discouraged bc "Macros have no Context" + no compiler enforcement for basic features (type & syntax correctness)
        Better alternative: a qualifier for variables, const 
            In C: constants cannot be changed. In C++, that and macros
        Because variables enforce a type, syntax and scope, instead of the preprocess, which is "out of the code".


    QUALIFIERS / SPECIFIER
        const size_t varName = 4; // this type of variable is specifically for array sizes. (means size_type)

    Enforces a compile behavior for an Object's member.
        const
            Throws compile errors if X is changed + optimizes X (immutability).
            Initialization =/= modifying.
            "Read-only"

            Can set const on FUNCTIONS, VARIABLES and ARGUMENTS
                FUNC: void printMoney(float amount) const{printf(amount)} //Nothing in the function can be modified.
                VAR: const int maxHealth = 100;
                ARG: void displayScore(const std::string& playerName) //Guarantees function won't modify the player's name.

                USE CASES
                Ensuring that a (getter) function will not modify its arguments or other aspects of the object.
                Everything in a const function must be const:
                    Must make sure any variable within is Const
                    Unless it's using a mutable member... see mutable below.
        volatile
            code is not optimized for these vars/structs/unions, by preventing caching in registers + removing seemingly redundant addresses (pointers?)
            "Can change at any time even from an outside source" (won't nec. find code nearby that modifies it). 
            Embedded Systems & Multithreaded programs
            Variables: when working with hardware registers or memory-mapped I/O: 
                EX: volatile int enemyStatus;
                We do not want accesses (DEFINE THIS) to be optimized as that could prevent read/writes from happening.  
        mutable 
            Forces MEMBER of a class (even a Const object) to be mutable (changeable).
                USE CASES:
                Make some functions const while using mutable variables within.
                Track internal data for an object, not affecting how other objects can interact with it.
                EX:
                public:
                    void updateScore() const{ ++score;} //
                private:
                    mutable int score = 0;

        inline
            Functions: Instead of being called, the contents of the function is expanded within the (expression?) at compilation. "STAMP"
                Code is therefore called multiple times if re-used, but removes all function-calling overhead (passing arguments, retrieving results)
        
        constexpr
            VARIABLE or RESULT OF A FUNCTION (expressions) evaluated at compile time, instead of runtime. 
            FUNC: Only does when given CONSTANT arguments.

        static (Specifier)

            LOCAL VARIABLES -> Extends lifetime to entire duration of program (Data segment of memory) instead of function execution (Stack segment).
                Can be used to generate values based on the previous function call (generateUniqueID, below) without defining variable in the caller function (main, below).
                    #include <iostream>
                    void generateUniqueID(){
                        static int id = 0; // Static local variable
                        ++id;
                        std::cout << "Generated ID: " << id << std::endl;
                    }

                    int main(){
                        generateUniqueID(); // Output: Generated ID: 1
                        generateUniqueID(); // Output: Generated ID: 2
                        generateUniqueID(); // Output: Generated ID: 3
                        return 0;
                    }
                    //id retains its value between calls to generateUniqueID, allowing it to produce unique IDs sequentially.
            CLASS MEMBERS -> Member is shared across all instances.
                Important: Available to code when no objects are defined, because global. Can call it with Scope::FuncName();
                class Enemy{
                public:
                    static int enemyCount; // Static class member

                    // This is the constructor, called every time a new Enemy object is instantiated.
                    Enemy(){
                        ++enemyCount; // Increase enemy count
                    }
                    //Any enemy can tell you how many enemies are left, without an enemy tracker.
            FUNCTIONS -> Linkage becomes internal: can only be accessed within that file
                Ex: Can create a function for use in 3 classes but is still inaccessible from outside of that file. Similar to "private" for encapsulating members, extending to non-class functions. No copy/paste into all 3 classes either!

DECLARATIONS can be done anywhere in the code, not all at the beginning. Hurray for modernity.

OPERATOR OVERLOADING
Redefining the operation to support combinations of inputs.
+ operator : works for integers as addition, but for strings it means concatenation.

For a quotient (x/y), int (5/9) == 0, but if either is a float or double, the output will change. 
Expressions change their size automatically to the largest value present in them.
((float)5/9) will result in an expression of type Float, where (5/9.0) will result in an expression of type Double.
The output of the expression can constrain the output; (5/9.0) output in an Integer will result in 0, despite the expression resulting in 0.555555...

    To declare an overload: declare multiple functions with:
    Same Name
    Different Parameters (dissociation based on params/arguments type or number)
    Same Scope (class or namespace, otherwise both can exist and be called manually with different scope resolution ::


ASSIGNMENTS
Line of code that assigns value to a variable.
Left hand must be able to hold a value, right-hand side is an expression.
Expression data types must match (not enforced by compiler)

FUNCTIONS
Scoped: global (as few as possible), in a namespace (usually better alternative to global) or as member of a class.
Must have a prototype (Declaration) and Implementation.
    Outside of main, write a function prototype before Main (so it can be used) and an implementation after Main.
        This IS Sequential. Compiler does go through line by line. No magic. 
    
Modular, Procedural blocks of code
Return a value
Receive arguments
    Arguments VS Parameters
    Arguments  = vars or constants sent to the function when called: add(3,5)
    Parameters = the variables in functions that take values of their arguments: int add(int a, int b)
Global or Members of a class (methods, in Java or Python)

No keyword! Same as a variable, but with parameters:
outputType functionName(parameters)

Specific Functions:
int main(commandlineArguments){ 
    functionBody
};
The main function can receive nothing, or STRINGS coming from command line (think command promt, functions with arguments after... dvars and such)

    FUNCTION PROTOTYPES
    When declaring a function, can set its parameters' type, return type and function name only. 
    Informs the compiler about the function.
    No need to set the parameters' NAMES. (typically .h file)
        EX: void add_student(int, std::string)
    They need to be defined in the function's PROCEDURE (implementation)(typically cpp file, or after the declaration)

    FUNCTION PARAMETERS
    Passed by value (copies, cannot modify values from the caller's scope)
        funcType funcName(argType argName){ //"square"
            x = x*x;
            return x;
        }
    By pointers (address as argument, can be dangerous)
        funcType funcName (argType *x, argType *y){ //"Swap"
            type temp = *x;
            *x = *y; //sets value 
            *y = *temp;
        }
        //To use this, must give an address to the parameters.
        funcName(&a, &b);

    By reference
        funcType funcName(argType& x, argType& y){ //Overload of "Swap"
            type temp = *x;
            x = y; //sets value 
            y = temp;
        }
        //No special naming for this, as refs are aliases to the original variables.
        funcName(a,b);

VIRTUAL FUNCTIONS


EXPRESSIONS
Temporary data storage unit which you must declare before usage with a type + name and can be initialized in declaration (like variables) 
Can contain variables, constants and operators, always producing a value

ORIENTATION
    NARROW / WIDE
    Character Types:
    Narrow characters
    A narrow character may not be able to represent all characters. Multiple narrow characters can be combined to form a multibyte character, which is a single logical character.
    Wide characters
    Wide characters can represent any character in a supported character set. Wide character literals start with the L prefix.

    Wide character types
    Some wide character types include:
    wchar_t: An implementation-defined wide character type. In the Microsoft compiler, wchar_t is a 16-bit wide character that stores Unicode encoded as UTF-16LE. 
    char8_t: An 8-bit wide character type that can store Unicode encoded as UTF-8. 
    char16_t: A 16-bit wide character type that can store Unicode encoded as UTF-16. 
    char32_t: A 32-bit wide character type that can store Unicode encoded as UTF-32. 
    Wide character string manipulation functions
    C++ provides functions for manipulating wide character strings, such as wcslen, wcscmp, wcsncpy, and wcstok.
    
    Char fall under (and can be interpreted as) integers.
        Strings -> Class, more practical than just using character arrays (still possible if you want)