
VARIABLES
Temporary data storage units. Must be declared prior to usage.
Declaration can contain initialization.
varType varName;
Can use types defined in libraries, std::string (check "std" for token "string")

Can declare multiple at once using commas, initializing as needed:
    int a, b = 5;

    CONSTANT LITERALS
    A value in your code that doesn't change.
    Examples:
    Numbers: 10, 3.14, 0, -5
    Characters: 'a', 'Z', '!'
    Strings: "Hello, world!", "This is a string"
    Boolean values: true, false

        CONSTANTS : named values representing a fixed value (PI)
        LITERAL : a fixed value (5)

COMMON DATA TYPE LIBRARIES : STRING STANDARD LIBRARY
    
    #include <string>

    INTEGERS
    stdint.h header file from the C library.    
    Made into C++. Name had a c added as prefix: <cstdint>
    Size is implementation-dependent:
        uint32_t
        int16_t
    U = unsigned, int = integer, number = bit size, _t = type\
    Signed = positive & negative. 
    long = larger, 64bit ints
        If you subtract an unsigned int below 0, it'll use the complement representation in binary: 4294967296 (2^32), i.e. starting from the other end.

    Integers = int, with an optional Radix (la base du nombre, base 8 base 12 base 16). default = Decimal, no radix specifier
    -5, 123, etc.
    Leading 0 = Octal (base 8) (ATTENTION)
    0x = Hexadecimal 0x10 (16) <--- Often used for bits, as 4bits = 16 (2^4)
    0b = Binary (1001)
    Trailing (suffix) U = Unsigned 23U   

    CHARACTERS
    char(8bits), 'h', '7', '\n' (single character), '\0'
    Can be entered as small integers (fitting in 8 bits) or as ASCII between single quotes = 'x'
    Backslash = escape character 
    '\0' == Null character, delimiting the end of a string
    '\n' == new line character



    BOOLEAN
    bool
    true, false
    Anything except 0 is true (implicit bool)
        In condition expressions, == 0 is thus optional. It'll implicitly be converted to a bool.
        if(number % 2) //If number is odd (true = anything other than 0)


    FLOAT
        Float literal = Trailing f = 23.05f
        double: default = 25.4
        long double = 3.12130192435409L
        At least 1 decimal, even if 0.0f

        Implementation defines min/max of what they represent.
        Follows standards like IEEE 754 https://en.wikipedia.org/wiki/Single-precision_floating-point_format
        https://stackoverflow.com/questions/14221612/difference-between-long-double-and-double-in-c-and-c 

    STRINGS
        Requires <string> STL (Standard Template Library)
        "string"
        Their type is a Pointer to a Const Char : when using typeid, will return Pointer to char: PKc (Pointer P, K constant, c Char)

VARIABLE MEMORY

Variables are declared at a specific scope.
    Global variables : managed statically  by compiler, held in memory until program is exited in the Data segment of memory.
    Local variables : within a given scope, held in memory as long as program remains in that scope.
        Exiting the scope == variables deleted from memory.
        Scope can be determined by {} : functions, classes, etc.
        "Automatic variables" == managed dynamically by compiler, allocated in the Stack segment of memory, which itself is temporary.

Type Inference: must initialize at declaration, but compiler infers the type of the variable.
    auto a =1, b = "", c = 'c', d = 3.14f, e = 12345678901, f = 3.14, g = true
        a = int32, e exceeds 32bits, so long int
        d = float, f = double
        g = boolean

Getting the Type:
typeid(varName).name()
    typeid is implementation dependent. Compilers will change the output... some more descriptive than others. Might be int or double, instead of i and d. Or even an error.
    name is a member function of each type.
i = int, l = long, f = float, d = double, b = bool, c = char, PKc (pointer to const char) = string

Shorthands:
Modifying variable, setting it    
    varName = varName + 2
    varName += 2




DATA TYPES
Representations encoded in bits that vary in length. 
cppreference.com/basic concepts/types
Primitive Types: basic category, without defined implementation (ex: int is primitive, vs uint32_t)
Portable Types: types that can be ported to different systems, because they are always declared and compiled with the same properties (behavior and size).  sdtint.h (library) defines fixed-width integers using the ISO C99 standard: int8_t (signed 8bit int) , uint32_t (unsigned 32bit int)

Fundamental/arithmetic/compound : https://en.cppreference.com/w/cpp/language/types
Complete/Incomplete: Wether it has all information required to define a space & layout in memory. This can apply to classes, data types, objects,  
Constant, Volatile:

    VOID
    Fundamental Type, empty set of value.


    INT (integer, variable # of bits, its length, based on implementation... generally 32bits, can be 16)
        SIGN / UNSIGNED
        Refers to the Positive/Negative split: signed 8-bit integer ranges from -128 to 127
        Unsigned ranges from 0 to 255.
        Sign is stored in the left-most bit (also called MostSignificantBit, MSB), typically the largest part of the value of the number
        
        Instead of using stdint.h library w/ ISO C99 standard, can declare them:
            unsigned int varName;
        
        Negative values loop back to the highest if stored in an unsigned variable; -2 will become 4294967294 
        It is equal to 2^32 -2, the "complement representation" in binary: exact same binary, but different interpretation.
    
    FLOAT (floating-point numbers: Real numbers) using IEEE754 binary floating point Standard
    Float
    Double : more precision and range, but computationally intense
    Long double

    BOOLEAN (true/false)
    bool
    In C++, {true,false} are defined as keywords for it. 0 = False, everything else = True

    CHAR (character, 8bits)
    ASCII as a byte. Can be used as an integer...

STRINGS
    Not native to C++
    Arrays of characters (char type), terminated with value 0 (null character)
    std library has it as a Class: <string> header includes the class and functions to manipulate the Class/data.
    <cstring> : header from the C library with functions to manipulate strings.

    String class should be used instead of character arrays... but if code NEEDS to be compatible w/ C, then we can use character arrays and import the <cstring> library to get the functions to achieve the same results as the C++ <string> header offers for its string class.



POINTERS
        Data type for memory addresses. System architecture (32bit, 64bit, 96bit) dictates maximum memory size of the pointer, ie. the full precision that data could ever be located at. Pointers will use X Bytes, depending on what they need to contain.
        (The content of a pointer is an Address)

        Declaring a pointer only allocates memory for the address, not for what's pointed to.

        Pointers are a type of iterator. 

        VOID
            Pointer of any type. Must be cast to another pointer type before.

        NULL and nullptr
            NULL = legacy, constant doesn't point to a valid address. Integer value 0 (bad type safety)
            nullptr = constant of type nullptr_t
                Type made for that purpose: no valid address
                Distinct type that is neither pointer nor member type
                Defined in header <cstddef>, std::nullptr_t
            Never dereference a null pointer.

        POINTERS AND ARRAYS
        Array variables (and strings, as arrays of chars), are a contiguous block of memory. They are not pointers, BUT they "decay" into a pointer to their first element. Immutable, sizeof returns the total array size in bytes (pointers return the pointer's size)
        EX:
        int arr[3] = {1, 2, 3};
        int *ptr = arr; // Pointer to the first element of the array. No need for & here.
        int *ptr = &arr[0] //equivalent line.

        Can move across arrays using the initial pointer: 
            *(ptr+1)  //doesn't change the pointer, but offsets address. ++ would've incremented. Compiler knows how many bytes to move to get to the next item.
            ptr[1] //doesn't change the pointer, but lets us use the pointer as if it was an array itself.
            [] // This operator actually does this: SUBSCRIPT, offsetting the address and dereferencing it.

        POINTERS AND OBJECTS
            Dynamic instances can be handled (memory de/allocated to them) with New/Delete
            Create them with new className(constructorArgs)
            delete className(destructorArgs)

            Dynamic Allocation of objects sends them to the HEAP.
            Automatic variables go to the STACK, and are removed as soon as the scope is left.
            See more in notes_memoryStructure



    Memory Map:
    Location (address), Unit (content)
    1 address per byte.
    32bit data (ex: int32)  == Each unit is 4 bytes

    May act as references to variables.
    Pointers have a type: int&, float&, string&...
    Can be used to access multiple different variables sequentially.
    
    Can also be VOID or NULL to point to any function or object requiring these.


        Symbols:
        dataType *ptrname;  (* == Indirection operator; "consider this an indirection")
        "ptrname points to a" (colloquial)

        ptrname = &a; (& == Address Of)
        

        *ptrName will return whatever is contained at the "pointed" address, in this ex., the value of a. Or in other words, a REFERENCE to a.

    Addresses will look like "0x7fffffffffde40"
        MAIN USE OF POINTERS : DYNAMIC MEMORY MANAGEMENT
        Allocation of memory (malloc functions) to create and remove data at runtime, instead of strictly at executable startup
        Called by constructors.

        ex: When creating an instance of class cow: 
            cow *my_cow;
            my_cow = new cow(constructor args);
        
        Q: Why is a pointer required here? 
        A: Because the variable is not at a static location on disk; it's somewhere dynamic. We can't ask program to predict it, and we do not want to reserve it.
        So we ask the program to create an address of type cow, then we tell program "create a new instance of what follows at this address".
        
        To use pointed data, *ptrName. 
        To access members of a class, basic way is: (*ptrName) to prioritize dereferencing the pointer in the sequence of operations.
            MemberOf (.) has a higher precedence than Dereferencing, so *ptr.member() does not work! It's trying to access a member of pointer itself. The pointer doesn't have members, what it points to has members.
            (*ptr).member() OR ptr->member()

        However, messy if trees and lists... Dedicated OPERATOR - MEMBER OF POINTER ->
        DESTRUCTOR (part of CLASSES)
            delete varName;
            This keyword calls the destructor function of a class and removes it from memory.
            Overloading the destructor:
                ~className(args....)


            Base Class Destructors are ALWAYS called (thanks, compiler) during object destruction

        SMART POINTERS
        To prevent "dangling pointers" and memory leaks.

        FUNCTION POINTERS
        returnType (*funcPtrIdentifier)(args[..]);
        funcPtrIdentifier = &funcName; //& optional. Address of Function.
        You can call a function through its address.


        POINTERS TO ARRAYS 
            int (*) 32 //Type "pointer to an array of 32 integers"

REFERENCES https://learn.microsoft.com/en-us/cpp/cpp/references-cpp?view=msvc-170 
    type& name = memberToReference
    Declares a named variable as a reference, that is, an alias to an already-existing object or function or named memory address (AKA Variable)

    Both Refs and Pointers store memory addresses.
    However, references act as the value contained at the address. Pointers act as addresses, which can be modified by anything that deals with addresses (iterator stuff, incrementing, decrementing)

    Initialization BINDS the address of an object to a reference. 2 types:   
        & lvalue - Locator Value, aka "expression refering to a memory location". Read&Write Alias : named references a Named variable
        && rvalue - Read-only Values. Used to extend lifetime of temporary objects or values without a specific memory address (temp or movable values)
                Temp objects: used to calculate and return data, then destroyed. (&&: rvalue or universal ref based on context. Universal ref = lvalue)
                Can be used to init lvalues
            Subcategories: 
                    Prvalues (Pure rvalues)
                        Literals: 5, "hello"
                        Function calls returning non-references: int getValue()
                        Temporary objects: std::string("temp")
                    XValues (Expiring values)
                    Expressions that represent objects that are about to be destroyed, allowing their resources to be reused.
                        Function calls returning rvalue references: std::string&& getString()
                        The result of std::move() - Used to transfer resources from 1 object to another to reduce copying. Converts lvalue to xvalue (triggering specific "move constructors" and "move assignment operators"  
            Glvalues (Generalized lvalues)
                Set of lvalues and xvalues: they have an identity (location in memory) 

            int main() {
            std::string name = "John"; // name is an lvalue
            std::string&& temp = std::move(name); // temp is an xvalue
            std::string otherName = std::move(temp); // otherName receives name's resources efficiently
            }




    When created, they are of "reference type". They decay to their referenceD type (int, float, wtvr) when used.
    Simple rewiring of tokens
        Not Pointers, nor objects(no array of ref bc no address)
        Cannot be used as addresses, only syntactically like objects.
        Always initialized (guarantee of finding data)
        1 Ref = Alias to a single object (at declaration)
        Single level of indirection, ever.

    USAGE OF REFERENCES:
        Passing parameters by ref (instead of by value)
            Allows modifying the argument variable directly within the function. (Bypassing limits of scope)
        Avoiding COPIES. Function parameters are typically (read: by default) copied. If large object, you do not want to unnecessarily copy it. 
        Optimizing ForLoops by avoiding copies each iteration.
            A form of for loop uses variable to iterate through a container. This variable MAY require copy each iteration.

VECTORS - STD (STL: standard template library, <vector>) (alternative for ARRAYS)
    Dynamic Size
    Memory-managed (unless objects within vector are manually allocated)
    Template - Generic container class (can implement for any type of element)
        Member functions to manipulate them
        Part of C++ STD library (generic programming style?)
        Iterators can be used (container): vectorName.begin() // iterator to the first element. .end() last element+1. Can do (instance.end()-1)->memberFunctionName, or prev(iterator, positionsToMoveBack
        Template<type>    

    Consecutive in Memory: 
        Can access with []

        Can only add items from the back end (furthest)
        .push_back()
        Indexed beginning at 0 : instance[2] returns the third element.

        .size() How many elements
        vectorVar.back() //Returns last element in the vector (NOT ITERATOR).
        .front() // Returns first element.

        .begin() //Returns Iterator: see below.
        .end()
        Can compare iterators (/pointers) like any other data types:
            Can loop using .begin() and incrementing (++ or next(iterator,#) in a while loop using != .end()
            Can loop using .size() and an integer

        .erase(iteratorToObject)
                auto it = find(begin,end, item)
                if (it != end)
                    erase(it)


ITERATORS
    Used to traverse containers.
    Work like pointers (addresses); use the same Operators, such as -> and *.
    "A pointer is the most basic form of an iterator, or conversely iterators are a generalization on the concept of a pointer."

    Can be incremented or decremented to move within a given container. +1 == next element in container. Incrementing a pointer is NOT the same thing: next element in memory, not only in container.

    Can use auto to determine type. Otherwise, vector<type>::iterator is the type for vector iterators.

    Dereferencing Iterators gives a reference (exactly like a pointer)

    Some classes, like Vectors, have functions that return iterators:
        vectorVar.begin() //Iterator to 1st element
        vectorVar.end() // Iterator to element AFTER last element.
        prev(iterator, number of elements to move) //Moving in the iterator, left/right 

        vectorVar.begin()->memberName //Content of the member through an operator, exactly like a pointer. 
        vectorVar.end()-1 //Iterator to last element of vector.

        .rbegin //Iterates in reverse order
        .rend

DECAY
    Decay refers to the process of converting certain types into simpler ones when passed as function arguments or used in other contexts.
    Can be called explicitly using std::decay_t<type[value]>

    ARRAYS
    - Using an array name in most expressions ; Arrays decay to pointers to their first element.
    - Passing an array to a function by value

    FUNCTIONS
    - Passing a function to another function by argument
    
    QUALIFIERS
    - const and volatile are removed

    REFERENCES
    -Converted to the type they refer to (instead of being "reference type")



TYPE CASTING
    Specify how to interpret data. 
        Both int and float can be used to represent the same number.
        Under the hood, they are very different in their binary encoding.
    STATIC CASTING
        C++-Style: static_cast<float>(expression)
        C-Style: (float)(expression)

    Implicit Conversion
        IF IT FITS within the new set of numbers, the Cast (conversion) will work as expected, converting from one binary encoding to the other when stored in a variable:
            float FloatVarName = 25.3; //type is defined as Float, but expression says Double (25.3f would be float). Implicitly converted to a Float.
            int IntVarName = FloatVarName // converts from 25.3 float to 25 int 
        IF IT DOES NOT FIT, copies the binary as-is when stored into a variable. You may see wrap-around:
            uint32_t = int32_t expression // converts from unsigned to signed, copying binary value as-is but interpreting it differently (wrapping around to show the complement value; -7 converted to 4294967289. Most significant bit = 1, AKA huge number.


    Explicit (Casting) Conversion: explicitly specifying the data type of an expression, so that the compiler interprets it as such.
        Syntax: (desiredType) expression // Expression that evaluates to value you want to convert
        uint32_t uint32_number= -7; // stores binary value as complement of -7, AKA 4294967289
        (int32_t) uint32_number // this expression will result in the expected -7 if printed, unlike Implicit conversion. This is because it took the binary value but interpreted it differently, as an unsigned int. IMPORTANT: the binary data in that variable is still the complement.

CONSTANT EXPRESSIONS
    (5/9) // This expression doesn't make it to the code (which is then executed by the processor).
        Why? Because it can be evaluated when compiled. 

    From Copilot:
        This can be evaluated when compiled:
        const int cn = 2;
        std::array<int, cn> a2; // OK: cn is a constant expression

        This can not, and would result in an error:
        int n = 1;
        std::array<int, n> a1; 

        const, or constexpr keywords, both enforce the value cannot be changed at runtime.



COLLECTIONS
    ARRAYS
    (see VECTORS for dynamically-sized, memory-managed arrays)
    Collections of data, all of the same type (as opposed to structs). 
    Fixed Size
    Indexed from 0 to N-1 (N = capacity of array)
    Contiguous in memory: next to each other, creating a sequential block of memory addresses
    Declaration only:
        varType arrayName[arrayCapacity];
    Declaration and Initialization:
        varType arrayName[] = {expression1, expression2, expression3};
        CANNOT use auto.
    Access (read/write)
        arrayName[itemIndex]
        arrayName[itemIndex] = expression;

    Size of arrays can use integers, or a specific type: size_t

    ENUMERATIONS
    List of named identifiers, that correspond to integers from 0 to x (enumerators).
        In C, operate in global scope... aka naming conflicts
        Limited type safety
    In C++ 11, Enum Classes (scoped enums, strongly typed enums). Encapsulation == OOP!
    Type Safety prevents implicit conversion between enum and int (not the same thing, can create errors)
    
    When you assign an enum to an int variable, you use its identifier, but code stores the integer associated with that identifier. 
    When you return that variable, it'll give you the integer identifier. THIS CAN BE DANGEROUS.
    Use Class Enums (see below) and make your variable of type enumClassName.
    When you return a class enum variable's value, it'll give you the identifier, and you can cast it to (int) if needed.


    Non-Scoped Enums example:

    enum varName {data0, data1, data2};
    int main(){
        int a;
        a = data1; //printing this will print 1, the corresponding enumerator of the enumeration)


        int a;
        int data1 = 5; //creating a local variable in scope of main.
        a = data1; //printing this will print 5, the corresponding enumerator of the enumeration)
    }
    int c;
    c = data1; //printing this will print 1, because the value 5 was only true as part of Main. Because a is a local variable in main, main would output it first. :: could be used to define the scope and get main's value... but still a problem. data0, data1, etc. are names which do not have a scope, as they're outside all functions. Reusing the name will cause an error: redefining the same names with potentially different values. What would the program output? This is compiled, not interpreted, so it doesn't simply take the last one.

    Class Enums (scoped, strongly typed): <cstdint>?
    enum class enumName{data0, data1, data2}; //because this is now a class, the values are in the scope of that class. No need for "" for strings; they are simply identifier tokens that can be interpreted as integers. Doing so returns the index in the enumeration, AKA the enumerator
    int main(){
        int a;
        // a = enumName::data1 (writing it like this will be an error if data1 isn't an int; that's expected (strongly typed))
        a = (int) enumName::data1 // casting as an integer

        // the alternative, preferable:
        enumName a; // this makes a variable of type enumName. It will contain 
        a = enumName::data1 // No type mismatch. To print it, we would need to cast it as another value: (int)a. It will return 1, the enumerator.
    }
    

CONSTANTS
    MACROS [Typically Do Not Use]
    macros or constant variables can achieve the same objective. Prefer const variables, as they have a scope.
    #define MACRO_NAME = 4;

        Useful as parameters in the code: size of screen, length of a memory buffer.
        Can be directives or variables.
        #define "find and replace" all of the instances of that symbol. AKA MACROS
        Can be discouraged bc "Macros have no Context" + no compiler enforcement for basic features (type & syntax correctness)
        Better alternative: a qualifier for variables, const 
            In C: constants cannot be changed. In C++, that and macros
        Because variables enforce a type, syntax and scope, instead of the preprocess, which is "out of the code".


    QUALIFIERS / SPECIFIER
        const size_t varName = 4; // this type of variable is specifically for array sizes. (means size_type)

    Enforces a compile behavior for an Object's member.
        const
            Throws compile errors if X is changed + optimizes X (immutability).
            Initialization =/= modifying.
            "Read-only"

            Can set const on FUNCTIONS, VARIABLES and ARGUMENTS
                FUNC: void printMoney(float amount) const{printf(amount)} //Nothing in the function can be modified.
                VAR: const int maxHealth = 100; //Nothing can change this variable
                ARG: void displayScore(const std::string& playerName) //Guarantees function won't modify the parameter, aka player's name.

                USE CASES
                Ensuring that a (getter) function will not modify its arguments or other aspects of the object.
                Everything in a const function must be const:
                    Must make sure any variable within is Const
                    Unless it's using a mutable member... see mutable below.
        volatile
            code is not optimized for these vars/structs/unions, by preventing caching in registers + removing seemingly redundant addresses (pointers?)
            "Can change at any time even from an outside source" (won't nec. find code nearby that modifies it). 
            Embedded Systems & Multithreaded programs
            Variables: when working with hardware registers or memory-mapped I/O: 
                EX: volatile int enemyStatus;
                We do not want accesses (DEFINE THIS) to be optimized as that could prevent read/writes from happening.  
        mutable 
            Forces MEMBER of a class (even a Const object) to be mutable (changeable).
                USE CASES:
                Make some functions const while using mutable variables within.
                Track internal data for an object, not affecting how other objects can interact with it.
                EX:
                public:
                    void updateScore() const{ ++score;} //
                private:
                    mutable int score = 0;

        inline
            Functions: Instead of being called, the contents of the function is expanded within the (expression?) at compilation. "STAMP"
                Code is therefore called multiple times if re-used, but removes all function-calling overhead (passing arguments, retrieving results)
        
        constexpr
            VARIABLE or RESULT OF A FUNCTION (expressions) evaluated at compile time, instead of runtime. 
            FUNC: Only does when given CONSTANT arguments.

        extern ( )


        static (Specifier)

            LOCAL VARIABLES -> Extends lifetime to entire duration of program (Data segment of memory) instead of function execution (Stack segment).
                Can be used to generate values based on the previous function call (generateUniqueID, below) without defining variable in the caller function (main, below).
                    #include <iostream>
                    void generateUniqueID(){
                        static int id = 0; // Static local variable
                        ++id;
                        std::cout << "Generated ID: " << id << std::endl;
                    }

                    int main(){
                        generateUniqueID(); // Output: Generated ID: 1
                        generateUniqueID(); // Output: Generated ID: 2
                        generateUniqueID(); // Output: Generated ID: 3
                        return 0;
                    }
                    //id retains its value between calls to generateUniqueID, allowing it to produce unique IDs sequentially.
            CLASS MEMBERS -> Member is shared across all instances.
                Important: Available to code when no objects are defined, because global. Can call it with Scope::FuncName();
                class Enemy{
                public:
                    static int enemyCount; // Static class member

                    // This is the constructor, called every time a new Enemy object is instantiated.
                    Enemy(){
                        ++enemyCount; // Increase enemy count
                    }
                    //Any enemy can tell you how many enemies are left, without an enemy tracker.
            FUNCTIONS -> Linkage becomes internal: can only be accessed within that file
                Ex: Can create a function for use in 3 classes but is still inaccessible from outside of that file. Similar to "private" for encapsulating members, extending to non-class functions. No copy/paste into all 3 classes either!

DECLARATIONS can be done anywhere in the code, not all at the beginning. Hurray for modernity.

OPERATOR OVERLOADING
https://en.cppreference.com/w/cpp/language/operators 
    Redefining the operation to support combinations of inputs.
    + operator : works for integers as addition, but for strings it means concatenation.

    For a quotient (x/y), int (5/9) == 0, but if either is a float or double, the output will change. 
    Expressions change their size automatically to the largest value present in them.
    ((float)5/9) will result in an expression of type Float, where (5/9.0) will result in an expression of type Double.
    The output of the expression can constrain the output; (5/9.0) output in an Integer will result in 0, despite the expression resulting in 0.555555...

    SYNTAX:
    Think of the operator: does it return something? (Ex: +=)
        returnType operatorOPERATORSYMBOL(args)
            Inventory& operator+=(const type& item) //Const used to garantee the input value isn't changed. 
            //From C++Ref https://en.cppreference.com/w/cpp/language/copy_assignment :
            //A copy assignment operator is a non-template non-static member function with the name operator= that can be called with an argument of the same class type and copies the content of the argument without mutating the argument.
            // Without Mutating the argument -> Const. See CPP REF : operators Canonical implementations
            // By ref: Does not COPY argument on the stack (not wasting memory/operating for no reason) 
                items->push_back(item);
                return *this
        Can return *this when dealing with modified objects' references.
ASSIGNMENTS
Line of code that assigns value to a variable.
Left hand must be able to hold a value, right-hand side is an expression.
Expression data types must match (not enforced by compiler)

FUNCTIONS
Scoped: global (as few as possible), in a namespace (usually better alternative to global) or as member of a class.
Must have a prototype (Declaration) and Implementation.
    Outside of main, write a function prototype before Main (so it can be used) and an implementation after Main.
        This IS Sequential. Compiler does go through line by line. No magic. 
    
Modular, Procedural blocks of code
Return a value
Receive arguments
    Arguments VS Parameters
    Arguments  = vars or constants sent to the function when called: add(a,b) // a and b
    Parameters = the variables in functions that take values of their arguments: int add(int a, int b) // a and b
Global or Members of a class (methods, in Java or Python)

No keyword! Same as a variable, but with parameters:
outputType functionName(parameters)

    FUNCTION SIGNATURE
    What defines a function. Not just its name:
    Name + Parameter Types.
        return type IS NOT part of signature 
    A function's SIGNATURE is what has to be unique when defining a function within a scope.
    This is what you define by DECLARING a function.
        Also why you can declare a function without giving names to the parameters.

Specific Functions: Main uses Command Line arguments!
int main(commandlineArguments){ 
    functionBody
};
The main function can receive nothing, or STRINGS coming from command line (think command promt, functions with arguments after... dvars and such)

    FUNCTION PROTOTYPES
    When declaring a function, can set its parameters' type, return type and function name only. 
    Informs the compiler about the function's PARAMS + RETURN TYPE
    No need to set the parameters' NAMES. (typically .h file)
        EX: void add_student(int, std::string)
    They need to be defined in the function's PROCEDURE (implementation)(typically cpp file, or after the declaration)

    FUNCTION PARAMETERS
    Passed by value (copies, cannot modify values from the caller's scope)
        funcType funcName(argType argName){ //"square"
            x = x*x;
            return x;
        }
    By pointers (address as argument, can be dangerous)
        funcType funcName (argType *x, argType *y){ //"Swap"
            type temp = *x;
            *x = *y; //sets value 
            *y = *temp;
        }
        //To use this, must give an address to the parameters.
        funcName(&a, &b);

    By reference
        funcType funcName(argType& x, argType& y){ //Overload of "Swap"
            type temp = *x;
            x = y; //sets value 
            y = temp;
        }
        //No special naming for this, as refs are aliases to the original variables.
        funcName(a,b);

    FUNCTIONS RETURNING POINTERS
        All functions that create a new dynamic object must return a pointer - it's the only way to access the new object!
        The return type should be a pointer.
            Weapon* createWeapon(const std::string& name){
                Weapon* weapon_x = new Weapon(name);
                return weapon_x;
            }
    FUNCTIONS RETURNING REFERENCES
    Useful to return existing objects (after sorting or seeking). Guarantees object is the expected one at the address - can't have refs pointing to something else.
        Player& findTopScorer(std::vector<Player>& players){ //function return a ref to a Player, using a reference to a vector(array) of Players. "players" is the argument.
            auto topScorer = players.begin(); //ITERATOR
            //code to find top scorer
            topScorer = &player; //references are addresses.
            return *topScorer; //Dereferencing operator on iterator
        }             

    FUNCTION OVERLOADING
        Same name, different parameters and/or return types.
        Declare it again, with different params.
        You CAN call another (instance?) of the same overloaded function: 
            "CalculateScore(int, double)" can call "CalculateScore(int,int)" to simplify its implementation.
        Same Scope (class or namespace, otherwise both can exist and be called manually with different scope resolution ::


    DEFAULT ARGUMENTS
        After adding an argument, assign a value. returnType functionName(type name = nameArgDefault)
            Once a default value is provided, all parameters to the right must also have default values. Can't skip arguments when calling.
            All mandatory arguments (no defaults) on the left.
            In the Declaration, not Definition.
            Reduces need for overloading! All combos of default arguments don't need to be declared as overloads.
            Backward compatibility: When modifying existing functions, default arguments can be used to add new parameters without breaking existing code that relies on the original function signature.

    VIRTUAL FUNCTIONS
    Member function that you expect to be redefined in derived classes.
    Makes it so a call to either the derived or base class invokes the derived class' definition.
    NonVirtual -> based on the ref/pointer type.

    ABSTRACT CLASSES
    Concepts off of which more specific classes can be derived. No objects of abstract classes can be created.
    As soon as a pure virtual function is created, it's an abstract class.
    "Pure" virtual functions:
        SYNTAX: "= 0"
            virtual returnTYpe name(args) = 0;
    
    No variables or member data.
    Not as argument types.
    Not as function return types.
    Not as explicit conversion types.

    Constructor cannot call pure virtual functions (Undefined), but can call other member functions as normal.
    Base Class Destructors are ALWAYS called (thanks, compiler) during object destruction, so defining even a pure virtual destructor is both mandatory and helpful.



EXPRESSIONS
Temporary data storage unit which you must declare before usage with a type + name and can be initialized in declaration (like variables) 
Can contain variables, constants and operators, always producing a value

ORIENTATION
    NARROW / WIDE
    Character Types:
    Narrow characters
    A narrow character may not be able to represent all characters. Multiple narrow characters can be combined to form a multibyte character, which is a single logical character.
    Wide characters
    Wide characters can represent any character in a supported character set. Wide character literals start with the L prefix.

    Wide character types
    Some wide character types include:
    wchar_t: An implementation-defined wide character type. In the Microsoft compiler, wchar_t is a 16-bit wide character that stores Unicode encoded as UTF-16LE. 
    char8_t: An 8-bit wide character type that can store Unicode encoded as UTF-8. 
    char16_t: A 16-bit wide character type that can store Unicode encoded as UTF-16. 
    char32_t: A 32-bit wide character type that can store Unicode encoded as UTF-32. 
    Wide character string manipulation functions
    C++ provides functions for manipulating wide character strings, such as wcslen, wcscmp, wcsncpy, and wcstok.
    
    Char fall under (and can be interpreted as) integers.
        Strings -> Class, more practical than just using character arrays (still possible if you want)